<h1 align="center">
 ❄️ Transfer Elements ❄️
</h1>

![Обложка](./assets/cover.png)

<p align="center">
  <a>
    <img src="https://img.shields.io/github/created-at/sineylo/transfer-elements?style=for-the-badge&logo=github&labelColor=%232E3440&color=%23D8DEE9" alt="GitHub created at">
  </a>
  <a>
    <img src="https://img.shields.io/npm/dw/transfer-elements?style=for-the-badge&logo=npm&labelColor=%232E3440&color=%23D8DEE9" alt="NPM downloads">
  </a>
  <a>
    <img src="https://img.shields.io/bundlejs/size/transfer-elements?style=for-the-badge&logo=npm&labelColor=%232E3440&color=%23D8DEE9" alt="NPM package minimized gzipped size">
  </a>
</p>

<p align="center">
  <strong>Будущее принадлежит тем, кто готовится к нему сегодня. (Малкольм Икс)</strong>
</p>

<p align="center">
  <a href="./readme.md">Документация на английском</a>
</p>

## ![Навигация](./assets/navigation-section-ru.png)

- [Описание](#description)
- [Преимущества](#advantages)
- [Установка](#installation)
- [Подключение](#connection)
- [Использование](#usage)
- [Параметры](#parameters)
- [Браузерная совместимость](#browser-compatibility)
- [Сообщество](#community)

<h2 id="description">
  <img src="./assets/description-section-ru.png" alt="Описание">
</h2>

«Transfer Elements» — библиотека, позволяющая вам динамически переносить какие-либо элементы из одного места в другое на брейкпоинтах.

### Зачем это может быть нужно?

Давайте представим, что дизайнер изначально подготовил макет только для компьютеров, в котором присутствует сложная шапка, состоящая из нескольких рядов. В одном из таких рядов находится поле ввода для поиска товаров и какие-то другие элементы. Через какое-то время дизайнер берётся за проектирование первого макета для адаптива и понимает, что полю поиска не хватает места и решает перенести его в более свободный ряд.

Нам, как разработчикам, нужно как-то решить эту задачу, а без использования JS существует два варианта, которые не очень хорошие.

Первый — продублировать разметку. Минус этого способа в том, что происходит раздувание кода. И ладно, если нужно перенести один `<div>`, а если целый раздел? В добавок на элементе может быть атрибут `id`, тогда ещё и его придётся изменять, так как два одинаковых `id` в разметке быть не может.

Второй — использовать абсолютное позиционирование. Этот вариант кажется неплохим, но на самом деле он ещё хуже, так как ломает доступность. Да, визуально элемент будет находиться там, где нам нужно, но вот в `DOM` он останется на прежнем месте. А программы для чтения с экрана в подавляющем большинстве ориентируется на `DOM`, а не на визуальное расположение, ибо оно может быть каким угодно.

Так вот библиотека **решает** эту проблему. Она просто «берёт» элемент из `DOM` и переносит его туда, куда вам нужно. При этом нет дублирования в разметке или использования абсолютного позиционирования.

---

Основная **цель** данной библиотеки — дать свободу для творчества веб-дизайнерам. Я считаю, что не они под нас должны подстраиваться, а мы под них. Чем больше начнёт появляться инструментов, позволяющих реализовать их задумки, тем быстрее мы придём к тому, когда каждый сайт будет выглядеть современно, а самое главное станет удобным для использования с любого устройства.

<h2 id="advantages">
  <img src="./assets/advantages-section-ru.png" alt="Преимущества">
</h2>

- **Без зависимостей**. Весь код написан с нуля и в нём отсутствуют сторонние решения.
- **Инновационная технология**. Библиотека основана на собственной технологии «Transfer Elements Simulation» (TES). Благодаря ей последовательный перенос (поднятие всей цепочки брейкпоинтов) выполняется только один раз.
- **Множественный перенос**. Максимальное количество брейкпоинтов не ограничено. Добавляйте их столько, сколько требуется для вашего проекта.
- **Двухэтапная проверка данных**. В библиотеку добавлено множество разнообразных проверок пользовательских данных. На первом этапе данные проверяются на соответствие необходимому типу. После этого наступает второй этап и проверяется возможность вставки в целевой элемент. Также в TES встроена дополнительная проверка на редкие случаи. Если что-то пойдёт не так, вы получите подробное сообщение об ошибке.
- **Доступность**. У брейкпоинтов отсутствует связь с какими-либо единицами измерения CSS. Несмотря на то, что есть некоторое сходство с пикселями (`px`), весь код библиотеки работает с обычным числом. Поэтому при изменении настроек шрифта в браузере ничего не сломается.
- **Скорость**. Помимо разового поднятия всей цепочки брейкпоинтов, поиск самого брейкпоинта, в момент основного переноса, выполняется за логарифмическое время `O(log n)`.

<h2 id="installation">
  <img src="./assets/installation-section-ru.png" alt="Установка">
</h2>

> [!IMPORTANT]
> Если вы не используете модули или используете, но хотите импортировать не из `node_modules`, пропустите данный раздел и переходите к следующему.

В зависимости от используемого вами менеджера пакетов выберите команду и запустите её в терминале.

```
npm install transfer-elements
```

```
yarn add transfer-elements
```

<h2 id="connection">
  <img src="./assets/connection-section-ru.png" alt="Подключение">
</h2>

### Модули

Если вы установили библиотеку, можете импортировать её из `node_modules`.

```JS
import TransferElements from 'transfer-elements';
```

Если вы не установили библиотеку, можете импортировать её из CDN.

```JS
import TransferElements from 'https://cdn.jsdelivr.net/npm/transfer-elements@1.0.7/dist/transfer-elements.esm.min.js'
```

### Тег \<script\>

Также, как и в случае с модулями, при желании вы можете использовать CDN.

```HTML
<script src="https://cdn.jsdelivr.net/npm/transfer-elements@1.0.7"></script>
```

Ссылка короче, чем для модулей, потому что файл запрашивается по умолчанию `transfer-elements.min.js`. Так или иначе вы можете указать полную ссылку.

```HTML
<script src="https://cdn.jsdelivr.net/npm/transfer-elements@1.0.7/dist/transfer-elements.min.js"></script>
```

### Прочее

Если все выше перечисленные варианты не подходят по какой-либо причине, можете [скачать файлы](https://registry.npmjs.org/transfer-elements/-/transfer-elements-1.0.7.tgz) и подключить библиотеку так как вам нужно.

<h2 id="usage">
  <img src="./assets/usage-section-ru.png" alt="Использование">
</h2>

> [!NOTE]
> В библиотеке добавлено достаточно большое количество проверок. Это нужно для того, чтобы в основной механизм поступали только правильные данные. Поэтому, даже если вы что-то сделаете не так, то в DevTools в разделе консоль увидите ошибку.

Первое, что понадобится сделать после подключения — вызвать конструктор.

```JS
new TransferElements();
```

Он принимает набор объектов `{}` с параметрами. То есть вы можете указать как один объект, так и несколько, если вам нужно перенести разные элементы. Для примера я укажу только один.

```JS
new TransferElements(
  {

  }
);
```

После этого добавим в объект первый и пожалуй самый важный параметр — `sourceElement`. Это элемент, который будет перенесён в другие элементы или в тот же самый, но с изменённой позицией, на брейкпоинтах, которые мы чуть позже укажем.

Так как значением этого параметра должен быть объект типа `Element`, то вы можете воспользоваться любым методом возвращающим такое значение. Я же чаще всего использую `document.getElementById()`, поэтому применю его.

```JS
new TransferElements(
  {
    sourceElement: document.getElementById('id-1')
  }
);
```

> [!TIP]
> Если вам потребуется перенести несколько элементов, то указывать объекты с ними вы можете в любом порядке. Механизм сам скорректирует порядок вставки, основываясь на порядке расположения этих элементов в DOM.

Затем добавим параметр `breakpoints`, значением которого должен быть объект типа `Object`. В нём будут храниться все брейкпоинты, на которых должен быть перенесён `sourceElement`.

```JS
new TransferElements(
  {
    sourceElement: document.getElementById('id-1'),
    breakpoints: {

    }
  }
);
```

> [!TIP]
> В основу библиотеки заложен подход `Desktop First`. Это значит, что перенос элементов будет осуществляться от большего брейкпоинта к меньшему. Но, не смотря на это, вы можете указывать брейкпоинты в любом порядке.

Сам брейкпоинт состоит из триггера типа `string`, то есть ключа, и объекта типа `Object`, который является значением. В качестве триггера допускается указать практически любое значение, которое может быть преобразовано к числу, за исключением нуля (при условии, что это целое число), отрицательных чисел и чисел выходящих за пределы `Number.MAX_SAFE_INTEGER`. Теперь я добавлю случайный брейкпоинт `990`.

```JS
new TransferElements(
  {
    sourceElement: document.getElementById('id-1'),
    breakpoints: {
      990: {

      }
    }
  }
);
```

Далее в объекте, относящемуся к брейкпоинту, нужно указать параметр `targetElement`. Его значением должен быть также, как и у `sourceElement` — объект типа `Element`. Этот параметр отвечает за элемент, в который должен быть перенесён `sourceElement`. По аналогии с `sourceElement` я воспользуюсь методом `document.getElementById()`.

```JS
new TransferElements(
  {
    sourceElement: document.getElementById('id-1'),
    breakpoints: {
      990: {
        targetElement: document.getElementById('id-2')
      }
    }
  }
);
```

Если вы всё сделали правильно и на этом этапе не появилось никаких ошибок, то, переключившись на указанный вами брейкпоинт, увидите, что `sourceElement` перенёсся в `targetElement` и находится в нулевой позиции. Счёт начинается с нуля, и важно помнить об этом.

Настало время поговорить про последний параметр — `targetPosition`. Это позиция, в которой `sourceElement` должен находиться в `targetElement`. Значением этого параметра может быть число от нуля до общего количества элементов в `targetElement` (включительно).

Допустим в `targetElement` находятся следующие элементы: `A, B, C`. Таким образом для `targetPosition` можно указать только: `0, 1, 2, 3`. Если вы укажете максимальную позицию, то есть `3`, то `sourceElement` будет вставлен в самый конец. Во всех остальных случаях `sourceElement` окажется на месте того элемента, который на данный момент занимает указанную позицию. Если у `targetElement` вообще нет дочерних элементов, то максимальной позицией будет `0` и в таком случае нет смысла указывать `targetPosition`. Это связано с тем, что параметр не является обязательным, а его значение по умолчанию — `0`.

Я укажу этот параметр со значением `1`. У вас возможно будет какая-то другая позиция.

```JS
new TransferElements(
  {
    sourceElement: document.getElementById('id-1'),
    breakpoints: {
      990: {
        targetElement: document.getElementById('id-2'),
        targetPosition: 1
      }
    }
  }
);
```

<h2 id="parameters">
  <img src="./assets/parameters-section-ru.png" alt="Параметры">
</h2>

| Название | Тип объекта | По умолчанию | Обязательный | Описание |
| -------- | ------------ | -------- | ---------- | ---------- |
| `sourceElement` | [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) | | Да | Элемент, который должен быть перенесён. |
| `breakpoints` | [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | | Да | Брейкпоинты, на которых должен быть перенесён `sourceElement`. |
| `targetElement` | [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) | | Да | Элемент, в который должен быть перенесён `sourceElement`. |
| `targetPosition` | [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) | `0` | Нет | Позиция, в которой `sourceElement` должен находиться в `targetElement`. |

<h2 id="browser-compatibility">
  <img src="./assets/browser-compatibility-section-ru.png" alt="Браузерная совместимость">
</h2>

<div align="center">
  <table>
    <thead>
      <tr>
        <th>Chrome 120</th>
        <th>Edge 120</th>
        <th>Safari 17</th>
        <th>Firefox 121</th>
        <th>Opera 106</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center">✅</td>
        <td align="center">✅</td>
        <td align="center">✅</td>
        <td align="center">✅</td>
        <td align="center">✅</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="community">
  <img src="./assets/community-section-ru.png" alt="Сообщество">
</h2>

Если у вас есть какие-то идеи, как можно улучшить библиотеку или что-то стало непонятно на каком-либо из этапов при чтении документации, не стесняйтесь и пишите в разделе «Issues», либо на почту: sineylodev@gmail.com. Я заинтересован в развитии своих продуктов, поэтому постараюсь максимально оперативно отвечать на все вопросы. Вместе мы сможем сделать процесс разработки интерфейсов в разы приятнее ✨
